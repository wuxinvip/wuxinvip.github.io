<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on 无心技术簿</title>
    <link>https://www.wuxinvip.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.wuxinvip.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计模式-创建型</title>
      <link>https://www.wuxinvip.com/blog/design-pattern/establish/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/design-pattern/establish/</guid>
      <description>设计模式创建型&amp;ndash;5种
单例&amp;mdash;-创建线程安全类
工厂&amp;mdash;-创建bean工厂
抽象工厂&amp;mdash;-创建bean工厂的工厂
原型&amp;mdash;-clone模式 &amp;mdash;用于数据流转中对象快速复制
建造者&amp;mdash;创建bean类型多样组合-创建方式不变-依靠算法实现不同组合创建bean
单例
/** * Created by huoyan403 on 2017/8/14. */ public class Singleton { //防止被引用 赋值为null 目的实现延迟加载 private static Singleton singleton = null; //私有化构造方法 private Singleton() { } //静态工程方法 创建实例 public static Singleton getSingleton(){ if(singleton == null){ //synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()， // 都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了 synchronized (singleton){ if(singleton == null) { singleton = new Singleton(); } } } return singleton; } //如果该对象被用于序列化 可以保证在序列化前后保持一致 public Object readResolve(){ return singleton; } }  工厂</description>
    </item>
    
    <item>
      <title>设计模式-结构型</title>
      <link>https://www.wuxinvip.com/blog/design-pattern/structure/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/design-pattern/structure/</guid>
      <description>设计模式-结构型&amp;ndash;7种
组合、适配器、过滤器、桥接、装饰、外观、享元、代理
组合&amp;ndash;最为常用&amp;ndash;将对象组合成一个树状结构、例如菜单上做自循环
适配器&amp;ndash;播放器格式适配&amp;ndash;对类型判定使用不同子类方法实例
桥接&amp;ndash;封装类组合形成一个复杂对象&amp;ndash;把复杂对象拆分简单对象
过滤器&amp;ndash;使用不同标准来过滤一组对象
装饰&amp;ndash;不增加子类-扩展类属性
外观&amp;ndash;外部定义一个高层接口-直接使用其属性
享元&amp;mdash;不太了解
代理&amp;ndash;使用一个类来代理另一个类来执行业务逻辑&amp;ndash;简单来讲-classB代理classA、classB来处理业务逻辑</description>
    </item>
    
    <item>
      <title>设计模式-行为型</title>
      <link>https://www.wuxinvip.com/blog/design-pattern/behavior/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/design-pattern/behavior/</guid>
      <description>设计模式行为型&amp;ndash;11种
责任链&amp;mdash;-请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。
命令&amp;mdash;-请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
解释器&amp;mdash;-这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
迭代器&amp;mdash;-这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
中介者&amp;mdash;-这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。
备忘录&amp;mdash;-保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。
观察者&amp;mdash;-当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。
状态&amp;mdash;-我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
空对象&amp;mdash;-在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。 这样的 Null 对象也可以在数据不可用的时候提供默认的行为。
策略 * 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。
 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。  模板
 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。 它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。  访问
 在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。 通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。 根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。  </description>
    </item>
    
  </channel>
</rss>