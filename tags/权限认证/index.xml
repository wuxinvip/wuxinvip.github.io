<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>权限认证 on 无心技术簿</title>
    <link>https://wuxinvip.github.io/tags/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/</link>
    <description>Recent content in 权限认证 on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wuxinvip.github.io/tags/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OAuth OAuth2</title>
      <link>https://wuxinvip.github.io/blog/service-permission/oauth-oauth2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/service-permission/oauth-oauth2/</guid>
      <description>翻了几篇子 认证 csdn 一个模样 连错误都一样
《用访问令牌到授权服务器换取访问令牌(accesstoken&amp;amp;secret)》 这叫人怎么理解 ？？
果断找官网 https://oauth.net/core/1.0a/
https://oauth.net/2/
OAuth2 授权类型 1、运行在网络服务器，基于浏览器和移动应用程序的应用程序的授权码【web授权】 2、密码为与登录用户名和密码 3、客户端凭证的应用程序访问 4、Implicit以前曾被推荐给没有秘密的客户，但已被使用授权代码授权而没有秘密取代。 OAuth认证和授权的过程如下: 1、用户访问第三方网站网站，想对用户存放在服务商的某些资源进行操作。 2、第三方网站向服务商请求一个临时令牌。 3、服务商验证第三方网站的身份后，授予一个临时令牌。 4、第三方网站获得临时令牌后，将用户导向至服务商的授权页面请求用户授权，然后这个过程中将临时令牌和第三方网站的返回地址发送给服务商。 5、用户在服务商的授权页面上输入自己的用户名和密码，授权第三方网站访问所相应的资源。 6、授权成功后，服务商将用户导向第三方网站的返回地址。 7、第三方网站根据临时令牌从服务商那里获取访问令牌。 8、服务商根据令牌和用户的授权情况授予第三方网站访问令牌。 9、第三方网站使用获取到的访问令牌访问存放在服务商的对应的用户资源。  国外文档：https://aaronparecki.com/oauth-2-simplified/
看不懂的用有道翻译啊[捂脸笑][捂脸笑][捂脸笑]
巨详细的请求解释 看看国内的 mmp</description>
    </item>
    
    <item>
      <title>权限系统_shiro_授权流程</title>
      <link>https://wuxinvip.github.io/blog/service-permission/shiro-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/service-permission/shiro-1/</guid>
      <description>Shiro Authorization （ 授权）
官方授权图片
步骤： 授权成功后
关于权限使用有三种方式
1、编写代码
2、JDK标签
3、JSPGSP标签库
这里要解释下 RBAC 以前的RBAC是 Role-Based-Access-Control
基于角色的访问控制
权限表 是 用户表-角色表-操作url表 【Menu】
控制方式是 用户拥有某权限&amp;mdash;&amp;mdash;&amp;ndash;权限拥有某url【controller】 才可以访问 麻烦点就是 后台判断用户是否拥有权限时，判断用户角色 那么就是把角色和资源绑定到一起、这样后期开发会发生这么一种情况、就是有个默认角色后期我可能要删除、使用新角色来控制这些资源、那么 到时候就要更新代码重新发布 而最新的RBAC是 Resource-Based-Access-Control 基于资源的访问控制
权限表是 用户表【user】-角色表-功能许可表【Permission】
控制方式就是 用户拥有某一角色&amp;mdash;&amp;mdash;&amp;ndash;角色拥有这一资源许可&amp;mdash;&amp;mdash;-资源许可和代码【controller】绑定在一起 后期要更改角色权限 就把这个角色删掉就可以了 并不会影响代码 不需要重构代码
shiro中同时使用两种方式进行 权限判断 用户可以自行选择 相关使用方法 参加xmind</description>
    </item>
    
    <item>
      <title>权限系统_shiro_验证流程</title>
      <link>https://wuxinvip.github.io/blog/service-permission/shiro-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/service-permission/shiro-2/</guid>
      <description>权限分为：操作权限、业务权限、数据权限三种
１、操作权限
现阶段操作权限都是使用shiro进行控制 shiro 也是基于RBAC思想 【不懂的小朋友就去百度RBAC】 shiro 的表设计　最基本的无张表：用户表、用户角色表、角色表、角色操作权限表、操作权限表、 一般也满足使用了　复杂点有用户组表　角色组表　等等　这些RBAC都有介绍  那么　What is Apache Shiro? Apache Shiro 是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。
这个比较牛逼、集成了 shiro 什么权限怎么控制的你就不用管了、照着他的文档使用就可以了、页面操作按钮【可以使用Tag控制】 web.xml　添加了拦截器之后、他能保证整个会话中都知道用户的权限、一直放到缓存中、你在整个流程中想要什么时候查询整个用户的角色、ｉｄ都可以直接通过他的方法拿到、那么他是怎么实现的呢？ 其实把他理解成一个封装工具或者一个安全框架也行、契合到项目中使用、简洁我们自己的代码、而且他这个工具还是Apache的　在安全方面还是比较值得信任的
那么他做了什么呢？　官方有以下说明： 验证用户来核实用户身份 对用户访问进行控制 判断用户是否被分配了一个确定的安全角色 判断用户是否被允许做某事 在任何环境下使用SessionAPI　即使没有　web　EJB容器 在身份验证、访问控制期间、会话的生命周期、对事件做出反应 聚集一个或多个用户安全数据源、并作为一个单一复合用户“视图” 启动单点登陆【SSO】功能 为没有关联登陆的用户启用　Remember Me服务 。。。
关于实现原理： shiro 团队　把这四个功能成为　应用程序的四大基石：身份认证、授权、会话管理、加密
shiro核心部分：
Authentication：有时也简称为“登录”，这是一个证明用户是他们所说的他们是谁的行为。 Authorization：访问控制的过程，也就是绝对“谁”去访问“什么”。 Session Management：管理用户特定的会话，即使在非 Web 或 EJB 应用程序。 Cryptography：通过使用加密算法保持数据安全同时易于使用。  看不懂？那么想想我们自己的登陆系统应该是怎样的呢？ 那么这样就好理解了　登陆就像是Authentication　管理用户标识　谁是谁　那么Authorization就像是登陆系统中的查看角色权限等功能＼管理谁应该访问什么资源　Session　Management　就是一个管理会话的工具　将返还的ticket放置在哪里传递给用户 Cryptography 暂时就理解为加密算法 额外功能： Web Support：Shiro 的 web 支持的 API 能够轻松地帮助保护 Web 应用程序。 Caching：缓存是 Apache Shiro 中的第一层公民，来确保安全操作快速而又高效。 Concurrency：Apache Shiro 利用它的并发特性来支持多线程应用程序。 Testing：测试支持的存在来帮助你编写单元测试和集成测试，并确保你的能够如预期的一样安全。 &amp;quot;Run As&amp;quot;：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。 &amp;quot;Remember Me&amp;quot;：在会话中记住用户的身份，所以他们只需要在强制时候登录。  分解下：</description>
    </item>
    
    <item>
      <title>权限系统_数据权限控制</title>
      <link>https://wuxinvip.github.io/blog/service-permission/permission-data/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://wuxinvip.github.io/blog/service-permission/permission-data/</guid>
      <description>1、使用 query filter  先举例说明一下数据权限，假设一个工作任务应用有以下的需求：
普通员工可以查看自己的工作项 部门经理可以查看自己管理部门的所有工作项 对于普通员工和部门经理，他们访问应用的入口都是相同的，应用需要根据不同的角色返回不一样的数据结果，这就是数据权限控制。
数据权限是个比较复杂的问题，规则非常灵活，在Leap中并没有内置实现，但提供了一个基础机制，可以相对简单的实现数据权限。
 1.1 查询过滤器（Query Filter）  查询过滤器是 ORM 模块中的功能，默认是关闭的，开启后所有的查询语句都会在 where 语句的最后自动加上类似 @filter(User) 的表达式。
假设执行查询语句：
select * from user u where u.name = :name 那么开启 Query Filter 后将会自动变为： select * from user u where ( u.name = :name ){? and ( @filter(User) )} 关于查询过滤器的细节在这里不展开细说，下面具体说明如何使用查询过滤器实现数据权限。   1.2 基于 Query Filter 实现数据权限
 1.3 开启
  修改 src/main/resources/conf/config.xml ，增加以下配置属性：
&amp;lt;properties prefix=&amp;quot;orm&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;query_filter.</description>
    </item>
    
  </channel>
</rss>