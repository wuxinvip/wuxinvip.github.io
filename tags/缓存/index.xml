<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>缓存 on 无心技术簿</title>
    <link>http://wuxinvip.github.io/tags/%E7%BC%93%E5%AD%98/</link>
    <description>Recent content in 缓存 on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://wuxinvip.github.io/tags/%E7%BC%93%E5%AD%98/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ehcache</title>
      <link>http://wuxinvip.github.io/blog/cache/ehcache/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/cache/ehcache/</guid>
      <description>ehcache service层缓存系统
发展史
Ehcache 开发者（S） Terracotta，Inc。[1] 稳定版本 3.3.0 / 2017年2月1日; 16个月前 写入 Java的 操作系统 跨平台 类型 高速缓存 执照 Apache许可证 2.0 网站 www.ehcache.org Ehcache是一个开源的Java 分布式缓存，用于通用缓存，Java EE和轻量级容器[ 澄清 ]。[2] Ehcache在Apache开源许可下可用。[1] Ehcache由Greg Luck于2003年开发。2009年，该项目由Terracotta购买，后者提供付费支持。 该软件仍然是开源软件，但一些新的主要功能（Fast Restartability Consistency）仅适用于Enterprise Ehcache和BigMemory等非开源的商业产品。 2011年3月，维基媒体基金会宣布将使用Ehcache来改善其维基项目的性能。[3]然而，在测试显示该方法的问题后，这很快就被放弃了。  </description>
    </item>
    
    <item>
      <title>memcached</title>
      <link>http://wuxinvip.github.io/blog/cache/memcached/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/cache/memcached/</guid>
      <description>memcached
简介
Memcached的 Memcached.svg 开发者（S） Danga Interactive 初始发行 2003年5月22日 稳定版本 1.5.8 / 2018年5月25日; 39天前[1] 知识库 https://github.com/memcached/memcached 在维基数据上编辑此内容 写入 C 操作系统 跨平台 类型 分布式内存缓存系统 执照 修订BSD许可证[2] 网站 memcached .org Memcached（发音：mem-cash-dee，mem-cashed）是一种通用的分布式内存缓存系统。它通常用于通过在RAM中缓存数据和对象来加速动态数据库驱动的网站，以减少必须读取外部数据源（如数据库或API）的次数。Memcached是免费的开源软件，根据修订的BSD许可证授权。[2] Memcached在类Unix操作系统（至少是Linux和OS X）和Microsoft Windows上运行。这取决于libevent库。 Memcached的API提供了一个分布在多台机器上的非常大的哈希表。当表已满时，后续插入会导致较旧的数据以最近最少使用（LRU）顺序被清除。[3] [4]使用Memcached的应用程序通常将请求和添加分层到RAM中，然后再回到较慢的后备存储（例如数据库）上。 Memcached没有内部机制来跟踪可能发生的未命中，但是，某些第三方实用程序提供此功能。  数据结构
key-value【string】  特点
client-server 结构 服务端、维护key-value 互不通信 客户端、自行管理数据在各个服务间的分配  性能
get获取时间戳、懒校验 内存不足 LRU算法、主动淘汰 多核存储、集群性能要高于redis 内存利用率要高于redis  集群
服务器互相独立 客户端hash存储数据  </description>
    </item>
    
    <item>
      <title>redis</title>
      <link>http://wuxinvip.github.io/blog/cache/redis/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/cache/redis/</guid>
      <description>1、使用ANSIC编写 （基于BSD协议） 2、开源、内存中数据结构存储 3、可以用作数据库、缓存、消息中间件
支持多种数据结构 String、hash、list、set、sorted sets、bitmaps、geospatial 字符串、散列、列表、集合、有序集合、bitmaps、地理空间
redis内置 复制(application) LUA脚本 LRU驱动事件、事物(transtrations) 和不同级别的硬盘持久化 并通过redis哨兵(sentinel)和自动分区(cluster)提高可用性
Redis支持每隔一段时间将数据导出磁盘、支持主从复制、且第一次是快速非阻塞形式
由于组合式压缩、内存使用率要高于memcached 其他：
事物 订阅分发 lua脚本 过期自动删除key 自动故障转移  优势
性能极高、读11W次/s 写8.1W次/s 丰富的数据类型 原子性操作 丰富特性、支持publish、sub scribe 通知 key过期等等  redis命令：
创建当前备份 save 恢复数据：config get dit &amp;quot;dir&amp;quot; &amp;quot;usr/local/redis/bin&amp;quot; 将dump移动到安装目录 并启动服务即可 创建备份： Bg save background saving started 该命令后台执行 恢复备份 redis-cli --rdb /tmp/dump.rdb 检查主从数据流：从模式 redis-cli --slave 从配置修改: slave-read-only yes 从数据库: slave of host:port 清空: flushall 远程连接: redis-cli -h host -p port -a password  redis发布订阅</description>
    </item>
    
    <item>
      <title>缓存淘汰算法</title>
      <link>http://wuxinvip.github.io/blog/cache/cache-elimination-algorithm/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/cache/cache-elimination-algorithm/</guid>
      <description>常见算法: LRU LRU-K 2Q MQ
缓存淘汰算法
缓存分析三大要点： 命中率、复杂度、代价 LRU 最近最少使用算法 FIFO 先入先出算法 MRU 最近最常使用算法 FIFO 先进先出 LFU 最少使用算法 LFU（Least Frequently Used）最近最少使用算法。 它是基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。 LRU LRU全称是Least Recently Used，即最近最久未使用的意思 注意LFU和LRU算法的不同之处，LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的。   /** * Created by huoyan403 on 2017/8/16. * * 这个类也被Tomcat所使用（ org.apache.tomcat.util.collections.LRUCache），但是在tomcat6.x版本中，已经被弃用，使用另外其他的缓存类来替代它。 */ public class LRUCache { private int cacheSize; private Hashtable nodes;//缓存容器 private int currentSize; private CacheNode first;//链表头 private CacheNode last;//链表尾 /** * 链表节点 * @author Administrator * */ class CacheNode { CacheNode prev;//前一节点 CacheNode next;//后一节点 Object value;//值 Object key;//键 CacheNode() { } } public LRUCache(int i) { currentSize = 0; cacheSize = i; nodes = new Hashtable(i);//缓存容器 } /** * 获取缓存中对象 * @param key * @return */ public Object get(Object key) { CacheNode node = (CacheNode) nodes.</description>
    </item>
    
  </channel>
</rss>