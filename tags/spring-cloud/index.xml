<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring Cloud on 无心技术簿</title>
    <link>http://wuxinvip.github.io/tags/spring-cloud/</link>
    <description>Recent content in Spring Cloud on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 Jun 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://wuxinvip.github.io/tags/spring-cloud/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>easy-cloud</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/easy-cloud/</link>
      <pubDate>Sat, 09 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/easy-cloud/</guid>
      <description>总有一件事 是你想做的
代码地址github
 add 用户认证请求授权 用户授权返回授权令牌 *第三方请求权限 返回请求令牌 *校验系统是否注册 *校验用户是否存在 保存redis mq落地db *返回授权调用code 一般使用一次 五分钟 *校验用户凭证 本系统分发出去用户确定用户有效唯一凭证 可以是登陆token * 第零 确定system是否有效 * 第一确定code有效 * 第二验证用户token * 第三分配数据访问权限 保存redis mq落地db * 第四 返回 授权令牌 * * 之后第三方系统 携带 系统id 用户账号 以及想访问的资源 向我系统请求数据  </description>
    </item>
    
    <item>
      <title>base-cloud</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/base-cloud/</link>
      <pubDate>Sun, 27 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/base-cloud/</guid>
      <description>他屌任他屌、我吃他大鸟
他皮任他皮、把他当瓜皮
代码地址gitee 代码地址github develop 分支</description>
    </item>
    
    <item>
      <title>EUREKA服务治理</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/eureka-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/eureka-1/</guid>
      <description>1、服务治理三个核心点、服务提供者、服务消费者、服务注册中心
结合Ribbon 服务治理图 服务治理时序图
服务提供者功能：
1、服务注册 2、服务同步 3、服务续约 4、..
服务注册： 服务提供者在启动时候通过rest请求 、将自己注册到Eureka Server上、同时携带自身服务的一些元数据信息、 Eureka Server接收到这个rest请求后 将这些元数据存储到一个双层结构Map中、其中第一层map 的key是服务名字、第二层key是具体服务实例名、 相关配置： eureka.client.register-with-eureka=true 【默认 true】 服务同步： 情景：两个相同的服务提供者实例、注册到了不同的服务注册中心、那么由于两个服务注册中心互相注册、服务注册中心会将服务注册信息发送给Eureka-server的其他机器、【还有一种说法是eureka-server 有信息服务功能、server与server之间 有消息同步、不确定这两种说法那个是真是的底层机制、后者是官方的说法、前者是 翟永超书里的说法、也就是说服务同步是由Eureka-server来完成的】 服务续约： 服务注册后、会维持一个心跳来维持服务不被剔除 相关配置： eureka: instance: status-page-url-path: /info //服务信息 health-check-url-path: /health //服务健康状态 lease-expiration-duration-in-seconds: 90 //服务失效时间 lease-renewal-interval-in-seconds: 30 //服务续约持续调用时间  服务消费者功能：
1、获取服务 2、服务调用 3、服务下线 4、..
获取服务： 服务消费者会发送一个rest请求获取一个服务列表、Eureka-server会发给client一个只读的服务列表、且该列表会30s刷新一次 相关配置： eureka: client: fetch-registry: true //默认为true 设为false则无法获取服务 registry-fetch-interval-seconds: 30 //服务清单刷新时间 服务调用： 集成Ribbon后、默认会使用轮询机制来调取服务实例信息 对于实例选择、在eureka中会有Region和Zone概念 一个Region会有很多Zone、每个服务都需要被注册到一个Zone中、所以每个client对应一个Region和一个Zone、服务调用时候会优先访问Zone下列表、没有在访问同一个Region不同Zone下的服务、 服务下线： 当服务实例jinx你给正常的关闭时、client会给server发送一个server、告知 &amp;quot;我要下线了&amp;quot;  服务注册中心功能：</description>
    </item>
    
    <item>
      <title>Feign服务调用</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/feign-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/feign-1/</guid>
      <description>为了服务之间的服务调用 基于Retrofit,
JAXRS-2.0,
andWebSocket.
开发的 客户端调用工具
更简单方便的调用服务信息
以下是官方简单介绍以及基本用法示例
github
interface Bank { @RequestLine(&amp;quot;POST /account/{id}&amp;quot;) Account getAccountInfo(@Param(&amp;quot;id&amp;quot;) String id); } @RequestMapping(value = &amp;quot;/test/&amp;quot;,method = RequestMethod.GET) RestResponse test(@RequestParam(&amp;quot;test&amp;quot;)Long test); /** * 带参调用方法 * @RequestLine(&amp;quot;POST /uc/login0&amp;quot;) * @Headers(&amp;quot;Content-type: application/json&amp;quot;) * String example0(@RequestParam(&amp;quot;id&amp;quot;) String id); * @RequestLine(&amp;quot;PUT /uc/login1&amp;quot;) * @Headers(&amp;quot;Content-type: application/json&amp;quot;) * String example1(@RequestBody UserVO userVO); * */  </description>
    </item>
    
    <item>
      <title>Hystrix</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/hystrix/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/hystrix/</guid>
      <description>原理
1、流程图 1、方法标注 @HystrixCommand注解 2、方法执行进入执行队列、方法执行、【图中标注 .toObservable()状态】 3、缓存是否可见【有 返回缓存数据；没有进入下一步判断】 4、断路器是否打开【未打开 直接判断信号量线程池是否拒绝 ；打开且触发断路进去fallback方法】 5、信号量线程池是否拒绝【未拒绝 创建线程池隔离舱执行业务逻辑 ；拒绝 执行fallback方法】 6、业务逻辑执行是否成功【成功 判断是否超时；未成功 执行fallback方法】 7、判断是否超时【超时 不返回 未超时返回数据】 8、fallback执行结果【成功 返回数据 ；失败 返回失败或者自行实现业务方法】 其中方法执行结果要返回断路器健康状态给断路器【也就是图中绿色4】  具体信息可见官方详细：https://github.com/Netflix/Hystrix/wiki/How-it-Works</description>
    </item>
    
    <item>
      <title>Reactor Core</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/reactor-core/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/reactor-core/</guid>
      <description>本文从 介绍下 Reactor （反应堆） 首先简单介绍Reactor 是什么东西、 其次解决什么问题、 领域应用、 原理、 优点和缺点、
1、简介 2、解决问题 3、领域应用 举个比较熟悉的例子 dubbo dubbo底层使用了netty线程模型 netty 中使用了reactor模式
那么什么是reactor模式？ Reactor三种模型 Netty线程模型 Netty结构 dubbo中使用的netty 4、Reactor 原理介绍
4.1 Reactor模式结构
4.2Reactor模式模块之间的交互
5、 Reactor优点
Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events 解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制等。 相比 传统的实现、即线程的切换、同步、数据的移动会引起性能问题。也就是说从性能的角度上，它最大的提升就是减少了性能的使用，即不需要每个Client对应一个线程
关于 减少使用线程使用 对性能提升的影响 可看这篇论文
SEDA: Staged Event-Driven Architecture - An Architecture for Well-Conditioned, Scalable Internet Service
对随着线程的增长带来性能降低做了一个统计：
在这个统计中，每个线程从磁盘中读8KB数据，每个线程读同一个文件，因而数据本身是缓存在操作系统内部的，即减少IO的影响；所有线程是事先分配的，不会有线程启动的影响；所有任务在测试内部产生，因而不会有网络的影响。该统计数据运行环境：Linux 2.2.14，2GB内存，4-way 500MHz Pentium III。从图中可以看出，随着线程的增长，吞吐量在线程数为8个左右的时候开始线性下降，并且到64个以后而迅速下降，其相应事件也在线程达到256个后指数上升。即1+1&amp;lt;2，因为线程切换、同步、数据移动会有性能损失，线程数增加到一定数量时，这种性能影响效果会更加明显。
6.Reactor模式的缺点</description>
    </item>
    
    <item>
      <title>Ribbon</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/ribbon/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/ribbon/</guid>
      <description>官方wiki地址：https://github.com/Netflix/ribbon/wiki
功能简介： 1、多重和可插入的负载平衡 2、与eureka服务整合 3、内置故障发现能力 4、云启用 5、与负载均衡器集成客户端 6、Archaius配置驱动客户端工厂
三个子项目： ribbon-core：包括负载均衡器和客户端接口定义、通用负载均衡器实现、客户端与负载均衡器和客户端工厂集成 ribbon-eureka：包含基于Eureka客户端的负载均衡器实现、这是用于服务注册和发现的liberary ribbon-httpclient：包含基于JSR-311的Rest客户端与服务均衡器集成的实现
配置 sample-client.properties
# Max number of retries on the same server (excluding the first try) sample-client.ribbon.MaxAutoRetries=1 # Max number of next servers to retry (excluding the first server) sample-client.ribbon.MaxAutoRetriesNextServer=1 # Whether all operations can be retried for this client sample-client.ribbon.OkToRetryOnAllOperations=true # Interval to refresh the server list from the source sample-client.ribbon.ServerListRefreshInterval=2000 # Connect timeout used by Apache HttpClient sample-client.</description>
    </item>
    
    <item>
      <title>cloud feign灵异事件</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud-exception/feign-exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud-exception/feign-exception-1/</guid>
      <description>报错 ： Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataSourceInitializerPostProcessor&#39;: Unsatisfied dependency expressed through field &#39;beanFactory&#39;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;com.****.feign.UserCenterFeignService&#39;: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.cloud.netflix.feign.FeignClientFactoryBean] from ClassLoader [sun.misc.Launcher$AppClassLoader@61e4705b]  解决办法 加入依赖
原因未明 、创建项目时候导入了feign 使用@EnableFeignClients注解 也ok 不报错 我就以为 feign包导入了 结果不知道哪来的包来的这个注解 导致 灵异事件 ```` ![image.png](http://upload-images.jianshu.io/upload_images/6434888-55ccd9dddc1f19e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  严重怀疑是这个包里的
mmp 莫名其妙的好了 仿佛又回到从前 你对java 一无所知&amp;hellip;&amp;hellip; ```</description>
    </item>
    
    <item>
      <title>sleuth灵异事件</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud-exception/sleuth-exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud-exception/sleuth-exception-1/</guid>
      <description>分布式 服务跟踪系统
客户端发送ok server端 启动ok 但是就是没有数据
``` 灵异原因：可能是版本不一致
要保证 客户端 cloud version 和sleuth server cloud version 版本一致 修改方式：
```` </description>
    </item>
    
    <item>
      <title>spring Roo</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/spring-roo/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/spring-roo/</guid>
      <description>what？ 使用命令行形式构建项目
下载地址：https://projects.spring.io/spring-roo/#running-from-shell
快速搭建：
 mkdir hello cd hello roo.sh roo&amp;gt; project setup --topLevelPackage com.foo roo&amp;gt; jpa setup --provider HIBERNATE --database HYPERSONIC_IN_MEMORY roo&amp;gt; entity jpa --class ~.domain.Timer roo&amp;gt; field string --fieldName message --notNull roo&amp;gt; repository jpa --all roo&amp;gt; service --all roo&amp;gt; web mvc setup roo&amp;gt; web mvc view setup --type THYMELEAF roo&amp;gt; web mvc controller --all --responseType THYMELEAF roo&amp;gt; web mvc controller --all --pathPrefix /api roo&amp;gt; quit mvn spring-boot:run  </description>
    </item>
    
    <item>
      <title>spring cloud 总 架构图</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/spring-cloud-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/spring-cloud-1/</guid>
      <description>版权所有 转载 请表明出处
相关代码地址
纠正：
cli 是 结合grovy脚本 工程 consul 是服务注册中心 不过可以结合docker做更容易扩散的集群中心   总结下 ： 可以说 spring cloud 服务中 包括各种spring 基础服务也有了很多更新 有RPC 框架的 注册 netflix 有 关于配置的 远程仓库配置 config 有 关于消息 bus stream 有关于app的 for android (提供RestTemplate) 有关任务调度 的 task 有关于 shell 编程 有关于安全方面的 有关于系统拦截 zuul 等等。 那么看名字可以分为两种 1、Spring * --- spring 为了完善&amp;quot;应用&amp;quot;增加的功能机制 例如 spring security 、spring vault、等等 2、Spring Cloud * ---spring cloud * 是在 微服务中 为了&amp;quot;微服务系统&amp;quot;更方便的集成 对各个功能模块进行封装的结果、  </description>
    </item>
    
    <item>
      <title>spring cloud 族谱</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/spring-cloud-2/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/spring-cloud-2/</guid>
      <description>功能简介来自官网 整理人：无心
总结下 ： 可以说 spring cloud 服务中 包括各种spring 基础服务也有了很多更新 有RPC 框架的 注册 netflix 有 关于配置的 远程仓库配置 config 有 关于消息 bus stream 有关于app的 for android (提供RestTemplate) 有关任务调度 的 task 有关于 shell 编程 有关于安全方面的 有关于系统拦截 zuul 等等。 那么看名字可以分为两种 1、Spring * --- spring 为了完善&amp;quot;应用&amp;quot;增加的功能机制 例如 spring security 、spring vault、等等 2、Spring Cloud * ---spring cloud * 是在 微服务中 为了&amp;quot;微服务系统&amp;quot;更方便的集成 对各个功能模块进行封装的结果、  </description>
    </item>
    
    <item>
      <title>zuul</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud/zuul/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud/zuul/</guid>
      <description>zuul
是架设在整个springcloud微服务服务网中的门户模块 所有的外界访问请求 都要经过 这个模块 zuul结合eureka 可以做到动态服务代理
实现功能：
 1、身份验证和安全性-识别每个资源的身份验证要求并拒绝不满足的要求 2、洞察和检测-在边缘跟踪有意义的数据和统计数据、以便为我们提供准确的生产视图 3、动态路由-根据需要将请求动态路由到不同的后端集群 4、压力测试-逐渐增加到群集的流量，以衡量表现 5、加载Shedding-为每种类型的请求分配容量，并删除超出限制的请求 6、静态响应处理-直接边缘建立响应、而不是将他们转发到内部群集 7、多区域弹性-跨AWS区域的路由请求、以使我们的ELB使用多样化、并使我们的边缘更接近我们的成员  组件包含： zuul-core ：包含编译和执行过滤器的核心功能的库 zuul-simple-webapp ：它显示了如何用zuul-core 构建一个应用程序的简单例子 zuul-netflix ： 将其他NetflixOSS组件添加到Zuul的库 使用功能区来执行路由请求 zuul-netflix-webapp ：webapp 把zuul-core 和 zuul-netflix 组合成一个 易于使用的软件包  官方架构 </description>
    </item>
    
    <item>
      <title>容器已经关闭</title>
      <link>http://wuxinvip.github.io/blog/spring-cloud-exception/exception-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://wuxinvip.github.io/blog/spring-cloud-exception/exception-1/</guid>
      <description>spring cloud task 启动报错 context has been closed already
解决办法 1.5.2 版本ok 2.0.0 报错容器已关闭 解决办法 #spring.cloud.task.closecontext_enabled=false  spring cloud Ribbon
解决办法
写到启动类就行
 spring boot &amp;lt;= 1.3 无需定义 spring boot &amp;gt;= 1.4 springboot不在维护 需要自己定义RestTempalte @Bean public RestTemplate restTemplate (RestTemplateBuilder builder){ //Do any additional configuration here return builder.build(); }  </description>
    </item>
    
  </channel>
</rss>