<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dubbo on 无心技术簿</title>
    <link>https://www.wuxinvip.com/tags/dubbo/</link>
    <description>Recent content in Dubbo on 无心技术簿</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Mar 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.wuxinvip.com/tags/dubbo/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>dubbo分析</title>
      <link>https://www.wuxinvip.com/blog/rpc/dubbo-1/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/rpc/dubbo-1/</guid>
      <description>手册地址:https://gitee.com/403403/RPC/raw/master/dubbo/doc/dubbo-用户指南-带标签.pdf  RPC Remote Procedure call 远程过程调用
一个RPC框架有几个特点: 远程调用.协议.暴露端口方式 稳定性.一致性.容错性 并发性. 简单插入性.高度解耦
那么从这几个方面来思考dubbo
协议:
Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。 缺省协议，使用基于mina1.1.7+hessian3.2.1的tbremoting交互。 连接个数：单连接 连接方式：长连接 传输协议：TCP 传输方式：NIO异步传输 序列化：Hessian二进制序列化 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。 适用场景：常规远程服务方法调用  高可用-容错性:
五种回调方式:Failover.Failfast.Failsafe.Failback.Forking 应对不同场景使用不同回调方式
高可用-负载均衡 dubbo支持 随机.轮询.最小调用次数调用.hash值余数调用
并发-线程 没什么可说的.该用就得用.但是不能乱用.
服务暴露地址:多协议.多注册方式.无中心化 参数校验.服务分组等等</description>
    </item>
    
    <item>
      <title>假如让你设计一个dubbo【一】</title>
      <link>https://www.wuxinvip.com/blog/rpc/dubbo-0/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.wuxinvip.com/blog/rpc/dubbo-0/</guid>
      <description>假设我们开发一个rpc远程调用框架
那么这个框架需要怎么去写
 1、首先有远程配置中心config 2、有服务代理层【包装业务上的服务做一个代理】 3、有服务注册中心【代理了服务之后 向该注册中心注册服务代理】 4、有路由【远程调用先走路由获取服务代理实例、集群必备的东西】 5、有远程调用层【发起服务调用】 6、有网络传输层、有信息交换层【这个是一个传输协议的实现层】 7、有序列化层【针对网络IO信息编码方式的统一、传输协议最基本的东西】 8、服务监控【不属于RPC、但是服务监控必不可少】  总结：
 核心配置：服务注册中心、服务代理和服务调用 优化配置：配置中心、服务监控、 基石配置：网络传输以及协议、序列化方式的定制  dubbo框架设计
简单用自己的语言描述这个图 * 1、左上角 Dubbo Framework * 2、左上角往右简单标识 每个颜色代表什么意思、更好理解图中数据流向 * 消费者、提供者、开始、接口、类、继承关系、调用链方向、依赖方向 * 3、左侧一竖列、黑体字 service\config、等等 * 服务接口【service】、配置层【config】、服务代理层【proxy】、注册中心【registry】、 * 路由【cluster】、监控中心【monitor】、远程调用【protocol】、 * 信息交换【exchange】、网络传输【transport】、数据序列化【serialize】
结合自己所想做一个分类
 核心配置：服务代理层【proxy】、注册中心【registry】、远程调用【protocol】 优化配置：配置层【config】、路由【cluster】、监控中心【monitor】 基石配置：信息交换【exchange】、网络传输【transport】、数据序列化【serialize】  简单猜想一下dubbo这么设计的代码架构
service：对外暴露接口 API与SPI分离 config：核心referenceConfig、ServiceConfig serviceConfig----获取远程仓库配置、获取文件配置、貌似还可以获取环境变量 【实质上跟修改本地host一个道理、规定了一个locahost代理 然后操作系统去解析这个配置】 referenceConfig--是消费端配置、其应该是从服务端获取配置信息 proxy：不由想到代理模式、原业务逻辑bean不变、新建bean来实现原bean的代理【也算是一种封装】 registry：注册中心、看过eureka、底层内存中维护了 一个双map结构数据列表、维护服务实例、服务地址、以及代理service等 cluster：路由器、想到最简单的就是url转发、当然肯定没这么简单、应该还会有、实时获取服务列表、负载均衡算法等等 monitor：监控中心、这个web服务把各路信息提上来做一个展示、应该没啥、最多维护一个硬盘文件 protocol：远程调用、怎么调用--不太清楚--再看看 exchange：信息交换、request、response封装 transport：网络传输、大名鼎鼎的netty就在这吧~~ seriallize：数据序列化、提供多重序列化方式、hessian【本地存根方式】、rmi等等吧  </description>
    </item>
    
  </channel>
</rss>